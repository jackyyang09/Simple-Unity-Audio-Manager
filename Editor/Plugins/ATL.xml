<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ATL</name>
    </assembly>
    <members>
        <member name="T:ATL.AudioData.AudioDataIOFactory">
            <summary>
            Factory for audio data readers
            </summary>
        </member>
        <member name="M:ATL.AudioData.AudioDataIOFactory.GetInstance">
            <summary>
            Gets the instance of this factory (Singleton pattern) 
            </summary>
            <returns>Instance of the AudioReaderFactory of the application</returns>
        </member>
        <member name="T:ATL.AudioData.AudioDataManager">
            <summary>
            Handles high-level basic operations on the given audio file, calling Metadata readers when needed
            </summary>
        </member>
        <member name="T:ATL.AudioData.AudioFileIO">
            <summary>
            This class is the one which is _really_ called when encountering a file.
            It calls AudioReaderFactory and queries AudioDataReader/MetaDataReader to provide physical 
            _and_ meta information about the given file.
            </summary>
        </member>
        <member name="M:ATL.AudioData.AudioFileIO.#ctor(System.String,System.Boolean,System.Boolean,System.IProgress{System.Single})">
            <summary>
            Constructor
            </summary>
            <param name="path">Path of the file to be parsed</param>
            <param name="readEmbeddedPictures">Embedded pictures will be read if true; ignored if false</param>
            <param name="readAllMetaFrames">All metadata frames (including unmapped ones) will be read if true; ignored if false</param>
        </member>
        <member name="M:ATL.AudioData.AudioFileIO.#ctor(System.IO.Stream,System.String,System.Boolean,System.Boolean,System.IProgress{System.Single})">
            <summary>
            Constructor
            </summary>
            <param name="stream">Stream to access in-memory data to be parsed</param>
            <param name="readEmbeddedPictures">Embedded pictures will be read if true; ignored if false</param>
            <param name="readAllMetaFrames">All metadata frames (including unmapped ones) will be read if true; ignored if false</param>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.FileName">
            <summary>
            Audio file name
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Title">
            <summary>
            Title of the track
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Artist">
            <summary>
            Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.AlbumArtist">
            <summary>
            Album Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.GeneralDescription">
            <summary>
            General description
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.OriginalAlbum">
            <summary>
            Original album
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.PaddingSize">
            <summary>
            Size of the padding zone, if any
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Comment">
            <summary>
            Comments
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.PictureTokens">
            <summary>
            Flag indicating the presence of embedded pictures
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Genre">
            <summary>
            Genre
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Track">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Disc">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.IntYear">
            <summary>
            Year, converted to int
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Album">
            <summary>
            Album title
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.IntDuration">
            <summary>
            Track duration (seconds), rounded
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.IntBitRate">
            <summary>
            Track bitrate (KBit/s), rounded
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Popularity">
            <summary>
            Track rating
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.CodecFamily">
            <summary>
            Codec family
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.IsVBR">
            <summary>
            Indicates whether the audio stream is in VBR
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Exists">
            <summary>
            Does the tag exist ?
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Date">
            <summary>
            Release date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Year">
            <summary>
            Year, in its original form
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.BitRate">
            <summary>
            Track bitrate (Kbit/s)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.SampleRate">
            <summary>
            Sample rate (Hz)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Duration">
            <summary>
            Track duration (milliseconds)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Size">
            <summary>
            Metadata size (bytes)
            </summary>
        </member>
        <member name="T:ATL.AudioData.CrossMetadataReader">
            <summary>
            Wrapper for reading multiple tags according to a priority
            
            Rule : The first non-empty field of the most prioritized tag becomes the "cross-detected" field
            There is no "field blending" across collections (pictures, additional fields) : the first non-empty collection is kept
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Exists">
            <summary>
            Returns true if this kind of metadata exists in the file, false if not
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Title">
            <summary>
            Title of the track
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Artist">
            <summary>
            Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Comment">
            <summary>
            Comments
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Genre">
            <summary>
            Genre
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Track">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Disc">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Date">
            <summary>
            Release date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Year">
            <summary>
            Year
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Album">
            <summary>
            Title of the album
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.AlbumArtist">
            <summary>
            Album Arist
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.GeneralDescription">
            <summary>
            General description
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.OriginalAlbum">
            <summary>
            Original album
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.PaddingSize">
            <summary>
            Size of the padding area, if any
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.PictureTokens">
            <summary>
            List of picture IDs stored in the tag
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.AdditionalFields">
            <summary>
            Any other metadata field that is not represented among above getters
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Chapters">
            <summary>
            Chapters
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Lyrics">
            <summary>
            Lyrics
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.EmbeddedPictures">
            <summary>
            Embedded pictures
            </summary>
        </member>
        <member name="T:ATL.AudioData.IAudioDataIO">
            <summary>
            This Interface defines an object aimed at giving audio "physical" data information
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.FileName">
            <summary>
            Full access path of the underlying file
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.BitRate">
            <summary>
            Bitrate (kilobytes per second)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.Duration">
            <summary>
            Duration (milliseconds)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.SampleRate">
            <summary>
            Sample rate (Hz)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.IsVBR">
            <summary>
            Returns true if the bitrate is variable; false if not
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.CodecFamily">
            <summary>
            Family of the audio codec (see AudioDataIOFactory for the list of codec families)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.ChannelsArrangement">
            <summary>
            Channels arrangement
            </summary>
        </member>
        <member name="M:ATL.AudioData.IAudioDataIO.IsMetaSupported(System.Int32)">
            <summary>
            Indicated whether the given metadata type is supported
            </summary>
            <param name="metaDataType">Metadata type to be tested (see list in MetaDataIOFactory)</param>
            <returns>True if current file supports the given metadata type; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IAudioDataIO.Read(System.IO.BinaryReader,ATL.AudioData.AudioDataManager.SizeInfo,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Reads audio data from the given stream.
            NB1 : Standard metadata (i.e. ID3v2, ID3v1 and APE) have to be read _before_ calling this method, and their size stored in sizeInfo
            NB2 : Stream is _not_ closed after reading; resource deallocation has to be done by the caller
            </summary>
            <param name="source">BinaryReader opened on the stream to read</param>
            <param name="sizeInfo">Description of the size of the undelying stream and associated metadata</param>
            <param name="readTagParams">Reading parameters and options</param>
            <returns>True if the stream has been successfuly read; false if not</returns>
        </member>
        <member name="T:ATL.AudioData.IMetaDataEmbedder">
            <summary>
            Describes an audio file that embeds standard metadata (e.g. ID3v2) in a native structure instead of keeping it at beginning/end of file as per standard use
            Currently used for AIFF/AIFC and DSF embedded ID3v2
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataEmbedder.HasEmbeddedID3v2">
            <summary>
            Indicates if file format has an embedded ID3v2 tag
            Return values
                -1 : Allowed by file format; status unknown because file has not been read yet
                0  : Allowed by file format, but not detected on this particular file
                >0 : Offset of detected embedded ID3v2
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataEmbedder.ID3v2EmbeddingHeaderSize">
            <summary>
            Size of the native header that precedes the ID3v2 embedded tag, if any (0 if no header)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataEmbedder.Id3v2Zone">
            <summary>
            Zone containing the ID3v2 tag
            </summary>
        </member>
        <member name="M:ATL.AudioData.IMetaDataEmbedder.WriteID3v2EmbeddingHeader(System.IO.BinaryWriter,System.Int64)">
            <summary>
            Writes the native header that precedes the ID3v2 embedded tag in the given stream, using the given tag size
            </summary>
            <param name="w">Stream to write the header to</param>
            <param name="tagSize">Tag size to be documented in the header to be written</param>
        </member>
        <member name="T:ATL.AudioData.IMetaDataIO">
            <summary>
            This Interface defines an object aimed at giving audio metadata information
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Exists">
            <summary>
            Returns true if this kind of metadata exists in the file, false if not
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Title">
            <summary>
            Title of the track
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Artist">
            <summary>
            Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Comment">
            <summary>
            Comments
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Genre">
            <summary>
            Genre
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Track">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Disc">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Date">
            <summary>
            Release date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Year">
            <summary>
            Year
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Album">
            <summary>
            Title of the album
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Popularity">
            <summary>
            Rating of the track, from 0% to 100%
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.OriginalAlbum">
            <summary>
            Title of the original album
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.GeneralDescription">
            <summary>
            General description
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.AlbumArtist">
            <summary>
            Album Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.PaddingSize">
            <summary>
            Size of padding area, if any
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.PictureTokens">
            <summary>
            List of picture IDs stored in the tag
                PictureInfo.PIC_TYPE : internal, normalized picture type
                PictureInfo.NativePicCode : native picture code (useful when exploiting the UNSUPPORTED picture type)
                NB : PictureInfo.PictureData (raw binary picture data) is _not_ valued here; see EmbeddedPictures field
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Size">
            <summary>
            Physical size of the tag (bytes)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.AdditionalFields">
            <summary>
            Contains any other metadata field that is not represented by a getter in the above interface
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.ChaptersTableDescription">
            <summary>
            Chapters table of contents description
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Chapters">
            <summary>
            Chapters
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Lyrics">
            <summary>
            Lyrics
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.EmbeddedPictures">
            <summary>
            List of pictures stored in the tag
            NB : PictureInfo.PictureData (raw binary picture data) is valued
            </summary>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.SetEmbedder(ATL.AudioData.IMetaDataEmbedder)">
            <summary>
            Set metadata to be written using the given embedder
            </summary>
            <param name="embedder">Metadata embedder to be used to write current metadata</param>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.Read(System.IO.BinaryReader,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Parse binary data read from the given stream
            </summary>
            <param name="source">Reader to parse data from</param>
            <param name="readTagParams">Tag reading parameters</param>
            <returns>true if the operation suceeded; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.Write(System.IO.BinaryReader,System.IO.BinaryWriter,ATL.TagData,System.IProgress{System.Single})">
            <summary>
            Add the specified information to current tag information :
              - Any existing field is overwritten
              - Any non-specified field is kept as is
            </summary>
            <param name="r">Reader to the resource to edit</param>
            <param name="w">Writer to the resource to edit</param>
            <param name="tag">Tag information to be added</param>
            <param name="writeProgress">Progress to be updated during write operations</param>
            <returns>true if the operation suceeded; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.Remove(System.IO.BinaryWriter)">
            <summary>
            Remove current tag
            </summary>
            <param name="w">Writer to the resource to edit</param>
            <returns>true if the operation suceeded; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.Clear">
            <summary>
            Clears all metadata
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.AAC">
            <summary>
            Class for Advanced Audio Coding files manipulation (extensions : .AAC)
            
            Implementation notes
            
                1. LATM and LOAS/LATM support is missing
            
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.AC3">
            <summary>
            Class for Dolby Digital files manipulation (extension : .AC3)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.AIFF">
            <summary>
            Class for Audio Interchange File Format files manipulation (extension : .AIF, .AIFF, .AIFC)
            
            Implementation notes
            
             1/ Annotations being somehow deprecated (Cf. specs "Use of this chunk is discouraged within FORM AIFC. The more refined Comments Chunk should be used instead"),
             any data read from an ANNO chunk will be written as a COMT chunk when updating the file (ANNO chunks will be deleted in the process).
            
             2/ Embedded MIDI detection, parsing and writing is not supported
             
             3/ Instrument detection, parsing and writing is not supported
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.AIFF.seekNextChunkHeader(System.IO.BinaryReader,System.Int64)">
            <summary>
            Reads ID and size of a local chunk and returns them in a dedicated structure _without_ reading nor skipping the data
            </summary>
            <param name="source">Source where to read header information</param>
            <returns>Local chunk header information</returns>
        </member>
        <member name="T:ATL.AudioData.IO.APE">
            <summary>
            Class for Monkey's Audio file manipulation (extension : .APE)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.APEtag">
            <summary>
            Class for APEtag 1.0 and 2.0 tags manipulation
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.APEtag.write(ATL.TagData,System.IO.BinaryWriter,System.String)">
            <summary>
            Writes the given tag into the given Writer using APEv2 conventions
            </summary>
            <param name="tag">Tag information to be written</param>
            <param name="w">Stream to write tag information to</param>
            <returns>True if writing operation succeeded; false if not</returns>
        </member>
        <member name="T:ATL.AudioData.IO.DSF">
            <summary>
            Class for DSD Stream File files manipulation (extension : .DSF)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.DTS">
            <summary>
            Class for Digital Theatre System files manipulation (extension : .DTS)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.DummyReader">
            <summary>
            Dummy audio data provider
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.DummyTag">
            <summary>
            Dummy metadata provider
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.FLAC">
            <summary>
            Class for Free Lossless Audio Codec files manipulation (extension : .FLAC)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FLAC.initialPictures">
            <summary>
             Write-time vars (TODO - find a better place than the whole class scope)
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.FLAC.adjustPictureZones(System.Collections.Generic.IList{ATL.PictureInfo})">
            <summary>
            Adjust the number of picture zones to match the actual number of pictures to be written
            </summary>
            <param name="picturesToWrite">List of pictures to be written</param>
        </member>
        <member name="M:ATL.AudioData.IO.FLAC.processPictureBlock(System.IO.BinaryWriter,System.Collections.Generic.IList{ATL.PictureInfo},System.Collections.Generic.IList{ATL.PictureInfo},System.Int32@,System.Int32@)">
            <summary>
            Process picture block at the index 'targetPictureIndex'
            Three outcomes :
                1/ Target picture cannot be written => block is marked for deletion
                2/ Target picture can be written and is identical to existing picture at the same position => block is left as it is
                3/ Target picture can be written and is different to existing picture at the same position => target picture is written
            </summary>
            <param name="w">Writer to be used</param>
            <param name="existingPictures">List of existing pictures on the file</param>
            <param name="picturesToWrite">List of pictures to write</param>
            <param name="existingPictureIndex">Current index of existing pictures in use in the main write loop</param>
            <param name="targetPictureIndex">Current index of target pictures in use in the main write loop</param>
            <returns></returns>
        </member>
        <member name="T:ATL.AudioData.IO.GYM">
            <summary>
            Class for Genesis YM2612 files manipulation (extensions : .GYM)
            
            Implementation notes
            
                1/ Looping : I have yet to find a GYM file that actually contains a loop.
                All archives I found so far are direct recording of game audio instructions
                that actually repeat the same pattern twice (looping data is not used at all)
                
                2/ Gzipped stream : I have yet to find a GYM file that contains gzipped data.
                => Rather than to make a theoretical implementation, there is no implementation at all.
            
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.ID3v1">
            <summary>
            Class for ID3v1.0-1.1 tags manipulation
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v1.write(ATL.TagData,System.IO.BinaryWriter,System.String)">
            <summary>
            Writes the given metadata into the given stream using the ID3v1.1 standard
            NB : Metadata fields that are not supported by ID3v1.1 standard (e.g. Composer) won't be written into the stream, even though their value are set
            </summary>
            <param name="tag">Metadata to be written</param>
            <param name="w">Stream to be used</param>
            <returns>True if operation completed successfuly; else false</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ATL.AudioData.IO.ID3v2" -->
        <member name="M:ATL.AudioData.IO.ID3v2.Read(System.IO.BinaryReader,System.Int64,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Reads ID3v2 data
            </summary>
            <param name="source">Reader object from where to read ID3v2 data</param>
            <param name="pictureStreamHandler">If not null, handler that will be triggered whenever a supported embedded picture is read</param>
            <param name="offset">ID3v2 header offset (mostly 0, except for specific audio containers such as AIFF or DSF)</param>
            <param name="storeUnsupportedMetaFields">Indicates whether unsupported fields should be read and stored in memory (optional; default = false)</param>
            <returns></returns>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.write(ATL.TagData,System.IO.BinaryWriter,System.String)">
            <summary>
            Writes the given tag into the given Writer using ID3v2.4 conventions
            </summary>
            <param name="tag">Tag information to be written</param>
            <param name="w">Stream to write tag information to</param>
            <returns>True if writing operation succeeded; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.extractGenreFromID3v2Code(System.String)">
            <summary>
            Extract genre name from String according to ID3 conventions
            </summary>
            <param name="iGenre">String representation of genre according to various ID3v1/v2 conventions</param>
            <returns>Genre name</returns>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.readBOM(System.IO.Stream)">
            <summary>
            Read Unicode BOM and return the corresponding encoding
            NB : This implementation _only_ works with UTF-16 BOMs defined in the ID3v2 specs ($FF FE 00 00 or $FE FF 00 00)
            </summary>
            <param name="source">Source stream</param>
            <returns>Properties of the BOM.
            If it has been found, stream is positioned on the next byte just after the BOM.
            If not, stream is positioned on its initial position before calling readBOM.
            </returns>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.decodeID3v2CharEncoding(System.Byte)">
             Returns the .NET Encoding corresponding to the ID3v2 convention (see below)
            
             Default encoding should be "ISO-8859-1"
             
             Warning : due to approximative implementations, some tags seem to be coded
             with the default encoding of the OS they have been tagged on
             
              $00    ISO-8859-1 [ISO-8859-1]. Terminated with $00.
              $01    UTF-16 [UTF-16] encoded Unicode [UNICODE], with BOM if version > 2.2
                     All strings in the same frame SHALL have the same byteorder.
                     Terminated with $00 00.
              $02    UTF-16BE [UTF-16] encoded Unicode [UNICODE] without BOM.
                     Terminated with $00 00.
              $03    UTF-8 [UTF-8] encoded Unicode [UNICODE]. Terminated with $00.
        </member>
        <member name="T:ATL.AudioData.IO.IT">
            <summary>
            Class for Impulse Tracker Module files manipulation (extensions : .IT)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.Midi">
            <summary>
            Class for Musical Instruments Digital Interface files manipulation (extension : .MID, .MIDI)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MOD">
            <summary>
            Class for Noisetracker/Soundtracker/Protracker Module files manipulation (extensions : .MOD)
            Based on info obtained from Thunder's readme (MODFIL10.TXT - Version 1.0)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MP4">
            <summary>
            Class for MP4 files manipulation (extensions : .MP4, .M4A, .M4B, .M4V)
            
            Implementation notes
            
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.MP4.readMP4(System.IO.BinaryReader,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Read MP4 header data
            http://www.jiscdigitalmedia.ac.uk/guide/aac-audio-and-the-mp4-media-format
            http://atomicparsley.sourceforge.net/mpeg-4files.html
            https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html
            - Metadata is located in the moov/udta/meta/ilst atom
            - Physical metadata are located in the moov/trak atoms
            - Binary physical data are located in the mdat atoms
            </summary>
            <param name="source">Source to read from</param>
            <param name="readTagParams">Reading parameters</param>
        </member>
        <member name="M:ATL.AudioData.IO.MP4.lookForMP4Atom(System.IO.Stream,System.String)">
            <summary>
            Looks for the atom segment starting with the given key, at the current atom level
            Returns with Source positioned right after the atom header, on the 1st byte of data
            
            Warning : stream must be positioned at the end of a previous atom before being called
            </summary>
            <param name="Source">Source to read from</param>
            <param name="atomKey">Atom key to look for (e.g. "udta")</param>
            <returns>If atom found : raw size of the atom (including the already-read 8-byte header);
            If atom not found : 0</returns>
        </member>
        <member name="T:ATL.AudioData.IO.MPEGaudio">
            <summary>
            Class for MPEG Audio Layer files manipulation (extensions : .MP1, .MP2, .MP3)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MPEGplus">
            <summary>
            Class for MusePack / MPEGplus files manipulation (extensions : .MPC, .MP+)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.Ogg">
            <summary>
            Class for OGG files manipulation. Current implementation covers :
              - Vorbis data (extensions : .OGG)
              - Opus data (extensions : .OPUS)
              
            Implementation notes
            
              1. CRC's : Current implementation does not test OGG page header CRC's
              2. Page numbers : Current implementation does not test page numbers consistency
            
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.OptimFrog">
            <summary>
            Class for OptimFROG files manipulation (extensions : .OFR, .OFS)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.PSF">
            <summary>
            Class for Portable Sound Format files manipulation (extensions : .PSF, .PSF1, .PSF2, 
            .MINIPSF, .MINIPSF1, .MINIPSF2, .SSF, .MINISSF, .DSF, .MINIDSF, .GSF, .MINIGSF, .QSF, .MINISQF)
            According to Neil Corlett's specifications v. 1.6
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.S3M">
            <summary>
            Class for ScreamTracker Module files manipulation (extensions : .S3M)
            
            Note : Parsing as it is considers the file as one single song. 
            Modules with song delimiters (pattern code 0xFF) are supported, but displayed as one track
            instead of multiple tracks (behaviour of foobar2000).
            
            As a consequence, modules containing multiple songs and exotic loops (i.e. looping from song 2 to song 1)
            might not be detected with their exact duration.
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.SPC">
            <summary>
            Class for SPC700 files manipulation (extensions : .SPC)
            According to file format v0.30; inspired by the SNESamp source (ID666.cpp)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.TAK">
            <summary>
            Class for Tom's lossless Audio Kompressor files manipulation (extension : .TAK)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.TTA">
            <summary>
            Class for True Audio files manipulation (extensions : .TTA)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.TwinVQ">
            <summary>
            Class for TwinVQ files manipulation (extension : .VQF)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.VGM">
            <summary>
            Class for Video Game Music files (Master System, Game Gear, SG1000, Genesis) manipulation (extensions : .VGM)
            According to file format v1.70
            
            Implementation notes :
              1/ GD3 tag format is directly implemented in here, since it is not a "real" standard and is only used for VGM files
              
              2/ Gzipped files are currently supported in read-only mode (i.e. ATL cannot write metadata to a GYM file containing gzipped data)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.VorbisTag">
            <summary>
            Class for Vorbis tags (VorbisComment) manipulation
            
            TODO - Rewrite as "pure" helper, with Ogg and FLAC inheriting MetaDataIO
            
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.WAV">
            <summary>
            Class for PCM (uncompressed audio) files manipulation (extension : .WAV)
            
            Implementation notes
            
                1. BEXT metadata - UMID field
                
                UMID field is decoded "as is" using the hex notation. No additional interpretation has been done so far.
                
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.WAVPack">
            <summary>
            Class for WavPack files manipulation (extension : .WV)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.WMA">
            <summary>
            Class for Windows Media Audio 7,8 and 9 files manipulation (extension : .WMA)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.XM">
            <summary>
            Class for Extended Module files manipulation (extensions : .XM)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MetaDataIO">
            <summary>
            Superclass that "consolidates" all metadata I/O algorithms to ease development of new classes and minimize their code
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MetaDataIO.ReadTagParams">
            <summary>
            Container class describing tag reading parameters
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.ReadTag">
            <summary>
            True : read metadata; False : do not read metadata (only "physical" audio data)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.ReadAllMetaFrames">
            <summary>
            True : read all metadata frames; False : only read metadata frames that match IMetaDataIO public properties (="supported" metadata)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.ReadPictures">
            <summary>
            True : read embedded pictures; False : skip embedded pictures
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.PrepareForWriting">
            <summary>
            True : read all data that will be useful for writing; False : only read metadata values
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.offset">
            <summary>
            File offset to start reading metadata from (bytes)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Exists">
            <summary>
            True if tag has been found in media file
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Version">
            <summary>
            Tag version
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Size">
            <summary>
            Total size of tag (in bytes)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Title">
            <summary>
            Song/piece title
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Artist">
            <summary>
            Artist (Performer)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.AlbumArtist">
            <summary>
            Album Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Album">
            <summary>
            Album title
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Track">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Disc">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Popularity">
            <summary>
            Rating, from 0 to 100%
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Year">
            <summary>
            Release year
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Date">
            <summary>
            Release date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Genre">
            <summary>
            Genre name
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Comment">
            <summary>
            Commment
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.OriginalAlbum">
            <summary>
            Original album
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.GeneralDescription">
            <summary>
            General Description
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.PaddingSize">
            <summary>
            Size of padding zone, if any
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.AdditionalFields">
            <summary>
            Collection of fields that are not supported by ATL (i.e. not implemented by a getter/setter of MetaDataIO class; e.g. custom fields such as "MOOD")
            NB : when querying multi-stream files (e.g. MP4, ASF), this attribute will only return stream-independent properties of the whole file, in the first language available
            For detailed, stream-by-stream and language-by-language properties, use GetAdditionalFields
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.PictureTokens">
            <summary>
            Each positioned flag indicates the presence of an embedded picture
            </summary>
        </member>
        <member name="T:ATL.AudioData.MetaDataIOFactory">
            <summary>
            Factory for metadata (tag) I/O classes
            </summary>
        </member>
        <member name="P:ATL.AudioData.MetaDataIOFactory.CrossReading">
            <summary>
            Sets whether the next created metadatareaders should use cross-tag reading
              - false           :  the most important tagging standard (according to priorities)
                                   detected on the track is exclusively used to populate fields
              - true (default)  :  for each field, the most important tagging standard (according to
                                   priorities) is first read. If the value is empty, the next
                                   tagging standard (according to priorities) is read, and so on...
            </summary>
        </member>
        <member name="M:ATL.AudioData.MetaDataIOFactory.GetInstance">
            <summary>
            Gets the instance of this factory (Singleton pattern) 
            </summary>
            <returns>Instance of the MetaReaderFactory of the application</returns>
        </member>
        <member name="M:ATL.AudioData.MetaDataIOFactory.SetTagPriority(System.Int32,System.Int32)">
            <summary>
            Modifies the default reading priority of the metadata
            </summary>
            <param name="tag">Identifier of the metadata type</param>
            <param name="rank">Reading priority (0..TAG_TYPE_COUNT-1)</param>
        </member>
        <member name="M:ATL.AudioData.MetaDataIOFactory.GetMetaReader(ATL.AudioData.AudioDataManager,System.Int32)">
            <summary>
            Gets the appropriate metadata reader for a given file / physical data reader
            </summary>
            <param name="theDataManager">AudioDataReader produced for this file</param>
            <param name="forceTagType">Forces a certain tag type to be read regardless of the current "cross reading" settings</param>
            <returns>Metadata reader able to give metadata info for this file (or the dummy reader if the format is unknown)</returns>
        </member>
        <member name="T:ATL.AudioData.FileStructureHelper">
            <summary>
            Helper class used to :
              - Record location and size of specific chunks of data within a structured file, called "Zones"
              - Record location, value and type of headers describing Zones
              - Modify these headers as Zones appear, disappear, expand or shrink
            </summary>
        </member>
        <member name="T:ATL.AudioData.FileStructureHelper.FrameHeader">
            <summary>
            Container class describing a frame header
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.Type">
            <summary>
            Header type (allowed values are TYPE_XXX within FrameHeader class)
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.Position">
            <summary>
            Position of the header
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.IsLittleEndian">
            <summary>
            True if header value is stored using little-endian convention; false if big-endian
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.ParentZone">
            <summary>
            Zone where the header is located physically
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.Value">
            <summary>
            Current value of the header (counter : number of frames / size : frame size / index : frame index (absolute) / rindex : frame index (relative to header position))
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.FrameHeader.#ctor(ATL.AudioData.FileStructureHelper.FrameHeader.TYPE,System.Int64,System.Object,System.Boolean,System.String)">
            <summary>
            Constructs a new frame header using the given field values
            </summary>
        </member>
        <member name="T:ATL.AudioData.FileStructureHelper.Zone">
            <summary>
            Container class describing a chunk/frame within a structured file 
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Name">
            <summary>
            Zone name (any unique value will do; used as internal reference only)
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Offset">
            <summary>
            Offset in bytes
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Size">
            <summary>
            Size in bytes
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.CoreSignature">
            <summary>
            Data sequence that has to be written in the zone when the zone does not contain any other data
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.IsDeletable">
            <summary>
            Indicates whether the zone contents are deletable by ATL (e.g. non-metadata zone is not deletable)
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Flag">
            <summary>
            Generic usage flag for storing information
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Headers">
            <summary>
            Size descriptors and item counters referencing the zone elsehwere on the file
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.Zone.#ctor(System.String,System.Int64,System.Int32,System.Byte[],System.Boolean,System.Byte)">
            <summary>
            Construct a new Zone using the given field values
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.Zone.Clear">
            <summary>
            Remove all headers
            </summary>
        </member>
        <member name="P:ATL.AudioData.FileStructureHelper.ZoneNames">
            <summary>
            Names of recorded zones
            </summary>
        </member>
        <member name="P:ATL.AudioData.FileStructureHelper.Zones">
            <summary>
            Recorded zones
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.#ctor(System.Boolean)">
            <summary>
            Construct a new FileStructureHelper
            </summary>
            <param name="isLittleEndian">True if unerlying file uses little-endian convention for number representation; false if big-endian</param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.Clear">
            <summary>
            Clears all recorded Zones
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.GetZone(System.String)">
            <summary>
            Retrieve a zone by its name
            </summary>
            <param name="name">Name of the zone to retrieve</param>
            <returns>The zone corresponding to the given name; null if not found</returns>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddZone(ATL.AudioData.FileStructureHelper.Zone)">
            <summary>
            Record a new zone by copying the given zone
            </summary>
            <param name="zone">Zone to be recorded</param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddZone(System.Int64,System.Int32,System.String,System.Boolean)">
            <summary>
            Record a new zone using the given fields
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddZone(System.Int64,System.Int32,System.Byte[],System.String,System.Boolean)">
            <summary>
            Record a new zone using the given fields
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.RemoveZone(System.String)">
            <summary>
            Remove the zone identified with the given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddCounter(System.Int64,System.Object,System.String,System.String)">
            <summary>
            Record a new Counter-type header using the given fields and attach it to the zone of given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddSize(System.Int64,System.Object,System.String,System.String)">
            <summary>
            Record a new Size-type header using the given fields and attach it to the zone of given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddIndex(System.Int64,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Record a new Index-type header using the given fields and attach it to the zone of given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddPendingIndex(System.Int64,System.Object,System.Boolean,System.String,System.String,System.String)">
            <summary>
            Record a new Index-type header using the given fields and attach it to the zone of given name, using a position relative to the last zone's offset
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.DeclareZone(System.String)">
            <summary>
            Declare a zone in advance; useful when reading header frames of containing upper frames, without having reached tag frame itself
            </summary>
            <param name="zone"></param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.addZoneHeader(System.String,ATL.AudioData.FileStructureHelper.FrameHeader.TYPE,System.Int64,System.Object,System.Boolean,System.String)">
            <summary>
            Record a new header using the given fields and attach it to the zone of given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.updateAllHeadersAtPosition(System.Int64,System.Object)">
            <summary>
            Update all headers at the given position to the given value
            (useful when multiple zones refer to the very same header)
            </summary>
            <param name="position">Position of header to be updated</param>
            <param name="newValue">New value to be assigned to header</param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.addToValue(System.Object,System.Int64,System.Object@)">
            <summary>
            Perform the addition between the two given values and encodes the result to an array of bytes, according to the type of the reference value
            </summary>
            <param name="value">Reference value</param>
            <param name="delta">Value to add</param>
            <param name="updatedValue">Updated value (out parameter; will be returned as same type as reference value)</param>
            <returns>Resulting value after the addition, encoded into an array of bytes, as the same type of the reference value</returns>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.RewriteHeaders(System.IO.BinaryWriter,System.Int64,ATL.AudioData.FileStructureHelper.ACTION,System.String,System.Int64)">
            <summary>
            Rewrite all zone headers in the given stream according to the given size evolution and the given action
            </summary>
            <param name="w">Stream to write modifications to</param>
            <param name="deltaSize">Evolution of zone size (in bytes; positive or negative)</param>
            <param name="action">Action applied to zone</param>
            <param name="zone">Name of zone</param>
            <returns></returns>
        </member>
        <member name="T:ATL.AudioData.TrackUtils">
            <summary>
            General utility class to manipulate values extracted from tracks metadata
            </summary>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ExtractTrackNumber(System.String)">
            <summary>
            Extract the track number from the given string
            </summary>
            <param name="TrackString">Raw "track" field in string form</param>
            <returns>Track number, in integer form; 0 if no track number has been found</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ExtractTrackTotal(System.String)">
            <summary>
            Extract the total track number from the given string
            </summary>
            <param name="TrackString">Raw "track" field in string form</param>
            <returns>Total track number, in integer form; 0 if no total track number has been found</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.DecodePopularity(System.String,System.Int32)">
            <summary>
            Extract rating level from the given string
            </summary>
            <param name="ratingString">Raw "rating" field in string form</param>
            <param name="convention">Tagging convention (see MetaDataIO.RC_XXX constants)</param>
            <returns>Rating level, in float form (0 = 0% to 1 = 100%)</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.DecodePopularity(System.Double,System.Int32)">
            <summary>
            Extract rating level from the given byte
            </summary>
            <param name="rating">Raw "rating" field in byte form</param>
            <param name="convention">Tagging convention (see MetaDataIO.RC_XXX constants)</param>
            <returns>Rating level, in float form (0 = 0% to 1 = 100%)</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.EncodePopularity(System.String,System.Int32)">
            <summary>
            Returns the given popularity encoded with the given convention
            </summary>
            <param name="ratingStr">Popularity (note 0-5), represented in String form (e.g. "2.5")</param>
            <param name="convention">Convention type (See MetaDataIO.RC_XXX constants)</param>
            <returns>Popularity encoded with the given convention</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ExtractIntYear(System.String)">
            <summary>
            Finds a year (4 consecutive numeric chars) in a string
            </summary>
            <param name="str">String to search the year into</param>
            <returns>Found year in integer form; 0 if no year has been found</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ExtractStrYear(System.String)">
            <summary>
            Finds a year (4 consecutive numeric chars) in a string
            </summary>
            <param name="str">String to search the year into</param>
            <returns>Found year in string form; "" if no year has been found</returns>
        </member>
        <member name="T:ATL.CatalogDataReaders.BinaryLogic.Cue">
            <summary>
            Class for cuesheet files reading (extension .cue)
            http://wiki.hydrogenaud.io/index.php?title=Cue_sheet
            </summary>
        </member>
        <member name="T:ATL.CatalogDataReaders.CatalogDataReaderFactory">
            <summary>
            Factory for Catalog data readers
            </summary>
        </member>
        <member name="T:ATL.CatalogDataReaders.ICatalogDataReader">
            <summary>
            Reads all tracks described in a container (e.g. : CUE sheet)
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Path">
            <summary>
            Absolute path of the container file
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Title">
            <summary>
            Title of the container
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Artist">
            <summary>
            Artist of the container
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Comments">
            <summary>
            Comments of the container
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Tracks">
            <summary>
            List of the tracks described in the container
            </summary>
        </member>
        <member name="M:ATL.ChannelsArrangements.GuessFromChannelNumber(System.Int32)">
            <summary>
            Returns the most commonly used ISO ChannelsArrangement corresponding to the given number of channels
            </summary>
            <param name="nbChannels">Number of channels</param>
            <returns>Most commonly used ISO ChannelsArrangement corresponding to the given number of channels</returns>
        </member>
        <member name="T:ATL.Format">
            <summary>
            Describes a file format
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PicType">
            <summary>
            Normalized picture type (see enum)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.NativeFormat">
            <summary>
            Native image format
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.Position">
            <summary>
            Position of the picture among pictures of the same generic type / native code (default 1 if the picture is one of its kind)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.TagType">
            <summary>
            Tag type where the picture originates from (see MetaDataIOFactory)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.NativePicCode">
            <summary>
            Native picture code according to TagType convention (numeric : e.g. ID3v2)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.NativePicCodeStr">
            <summary>
            Native picture code according to TagType convention (string : e.g. APEtag)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.Description">
            <summary>
            Picture description
            </summary>
        </member>
        <member name="P:ATL.PictureInfo.PictureData">
            <summary>
            Binary picture data
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PictureHash">
            <summary>
            Hash of binary picture data
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.MarkedForDeletion">
            <summary>
            True if the field has to be deleted in the next IMetaDataIO.Write operation
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.TransientFlag">
            <summary>
            Freeform transient value to be used by other parts of the library
            </summary>
        </member>
        <member name="T:ATL.TagData">
            <summary>
            Basic metadata fields container
            
            TagData aims at staying a basic, universal container, without any Property accessor layer nor any field interpretation logic
            </summary>
        </member>
        <member name="F:ATL.TagData.Chapters">
            <summary>
            Chapters 
            NB : The whole chapter list is processed as a whole
            </summary>
        </member>
        <member name="F:ATL.TagData.Lyrics">
            <summary>
            Lyrics
            </summary>
        </member>
        <member name="F:ATL.TagData.Pictures">
            <summary>
            Embedded pictures
            NB : Each entry is processed as a metadata field on its own
            </summary>
        </member>
        <member name="F:ATL.TagData.AdditionalFields">
            <summary>
            Additional fields = non-classic fields
            NB : Each entry is processed as a metadata field on its own
            </summary>
        </member>
        <member name="F:ATL.TagData.TrackDigitsForLeadingZeroes">
            <summary>
            > 0 if Track field is formatted with leading zeroes over X digits
            </summary>
        </member>
        <member name="F:ATL.TagData.DiscDigitsForLeadingZeroes">
            <summary>
            > 0 if Disc field is formatted with leading zeroes over X digits
            </summary>
        </member>
        <member name="F:ATL.TagData.DataSizeDelta">
            <summary>
            Current delta of written data size vs. initial data size
            </summary>
        </member>
        <member name="F:ATL.TagData.PaddingSize">
            <summary>
            Size of padding area, if any (target size of padding area, if used as input)
            </summary>
        </member>
        <member name="F:ATL.TagData.DurationMs">
            <summary>
            Duration of audio track, in milliseconds
            </summary>
        </member>
        <member name="M:ATL.TagData.IntegrateValue(System.Byte,System.String)">
            <summary>
            Stores a 'classic' metadata value into current TagData object according to its key
            
            NB : This method cannot be used to store non-classic fields; use tagData.AdditionalFields instead
            </summary>
            <param name="key">Identifier describing the metadata to store (see TagData public consts)</param>
            <param name="value">Value of the metadata to store</param>
        </member>
        <member name="M:ATL.TagData.IntegrateValues(ATL.TagData,System.Boolean,System.Boolean)">
            <summary>
            Merge given TagData object with current TagData object
            </summary>
            <param name="data">TagData object to merge</param>
        </member>
        <member name="M:ATL.TagData.ToMap">
            <summary>
            Converts non-null 'classic' fields values into a properties Map
            
            NB : Additional fields, pictures and chapters won't be part of the Map
            </summary>
            <returns>Map containing all 'classic' metadata fields</returns>
        </member>
        <member name="M:ATL.TagData.Clear">
            <summary>
            Clears all values stored in TagData object
            </summary>
        </member>
        <member name="M:ATL.TagData.addIfConsistent(System.String,System.Byte,System.Collections.Generic.IDictionary{System.Byte,System.String})">
            <summary>
            Adds given value to given map if value is not null
            </summary>
            <param name="data">Value to add to the map</param>
            <param name="id">Key to add to the map</param>
            <param name="map">Target map to host given values</param>
        </member>
        <member name="M:ATL.TagData.emptyIfZero(System.String)">
            <summary>
            Converts given value to empty string ("") if null or zero ("0")
            </summary>
            <param name="s">Value to convert</param>
            <returns>If null or zero ("0"), empty string (""); else initial value</returns>
        </member>
        <member name="M:ATL.TagData.generatePicturePositions">
            <summary>
            Builds a map containing the position of each picture in the Pictures field, based on the PictureInfo.Position fields
            
            NB : This method does not calculate any position; it just generates the map
            </summary>
            <returns>Map containing the position for each picture</returns>
        </member>
        <member name="T:ATL.Track">
            <summary>
            High-level class for audio file manipulation
            </summary>
        </member>
        <member name="M:ATL.Track.#ctor">
            <summary>
            Basic constructor; does nothing else than instanciating the Track object
            </summary>
        </member>
        <member name="M:ATL.Track.#ctor(System.String,System.IProgress{System.Single},System.Boolean)">
            <summary>
            Loads the file at the given path
            Only works with local paths; http, ftp and the like do not work.
            </summary>
            <param name="Path">Path of the local file to be loaded</param>
        </member>
        <member name="M:ATL.Track.#ctor(System.String,System.Boolean)">
            <summary>
            Loads the file at the given path
            Only works with local paths; http, ftp and the like do not work.
            </summary>
            <param name="Path">Path of the local file to be loaded</param>
        </member>
        <member name="M:ATL.Track.#ctor(System.IO.Stream,System.String,System.IProgress{System.Single})">
            <summary>
            Loads the raw data in the given stream according to the given MIME-type
            </summary>
            <param name="stream">Stream containing the raw data to be loaded</param>
            <param name="mimeType">MIME-type (e.g. "audio/mp3") or file extension (e.g. ".mp3") of the content</param>
        </member>
        <member name="F:ATL.Track.Path">
            <summary>
            Full path of the underlying file
            </summary>
        </member>
        <member name="P:ATL.Track.Title">
            <summary>
            Title
            </summary>
        </member>
        <member name="P:ATL.Track.Artist">
            <summary>
            Artist
            </summary>
        </member>
        <member name="P:ATL.Track.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.Track.Comment">
            <summary>
            Comments
            </summary>
        </member>
        <member name="P:ATL.Track.Genre">
            <summary>
            Genre
            </summary>
        </member>
        <member name="P:ATL.Track.Album">
            <summary>
            Title of the album
            </summary>
        </member>
        <member name="P:ATL.Track.OriginalAlbum">
            <summary>
            Title of the original album
            </summary>
        </member>
        <member name="P:ATL.Track.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.Track.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.Track.Description">
            <summary>
            General description
            </summary>
        </member>
        <member name="P:ATL.Track.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.Track.AlbumArtist">
            <summary>
            Album Artist
            </summary>
        </member>
        <member name="P:ATL.Track.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.Track.Date">
            <summary>
            Recording Date
            </summary>
        </member>
        <member name="P:ATL.Track.Year">
            <summary>
            Recording Year
            </summary>
        </member>
        <member name="P:ATL.Track.TrackNumber">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.Track.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.Track.DiscNumber">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.Track.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.Track.Popularity">
            <summary>
            Popularity (0% = 0 stars to 100% = 5 stars)
            e.g. 3.5 stars = 70%
            </summary>
        </member>
        <member name="P:ATL.Track.PictureTokens">
            <summary>
            List of picture IDs stored in the tag
                PictureInfo.PIC_TYPE : internal, normalized picture type
                PictureInfo.NativePicCode : native picture code (useful when exploiting the UNSUPPORTED picture type)
                NB : PictureInfo.PictureData (raw binary picture data) is _not_ valued here; see EmbeddedPictures field
            </summary>
        </member>
        <member name="P:ATL.Track.ChaptersTableDescription">
            <summary>
            Chapters table of content description
            </summary>
        </member>
        <member name="P:ATL.Track.Chapters">
            <summary>
            Contains any other metadata field that is not represented by a getter in the above interface
            </summary>
        </member>
        <member name="P:ATL.Track.Lyrics">
            <summary>
            Synchronized and unsynchronized lyrics
            </summary>
        </member>
        <member name="P:ATL.Track.Bitrate">
            <summary>
            Bitrate (kilobytes per second)
            </summary>
        </member>
        <member name="P:ATL.Track.SampleRate">
            <summary>
            Sample rate (Hz)
            </summary>
        </member>
        <member name="P:ATL.Track.IsVBR">
            <summary>
            Returns true if the bitrate is variable; false if not
            </summary>
        </member>
        <member name="P:ATL.Track.CodecFamily">
            <summary>
            Family of the audio codec (See AudioDataIOFactory)
            0=Streamed, lossy data
            1=Streamed, lossless data
            2=Sequenced with embedded sound library
            3=Sequenced with codec or hardware-dependent sound library
            </summary>
        </member>
        <member name="P:ATL.Track.Duration">
            <summary>
            Duration (seconds)
            </summary>
        </member>
        <member name="P:ATL.Track.DurationMs">
            <summary>
            Duration (milliseconds)
            </summary>
        </member>
        <member name="P:ATL.Track.ChannelsArrangement">
            <summary>
            Channels arrangement
            </summary>
        </member>
        <member name="P:ATL.Track.AdditionalFields">
            <summary>
            Contains any other metadata field that is not represented by a getter in the above interface
            </summary>
        </member>
        <member name="P:ATL.Track.EmbeddedPictures">
            <summary>
            List of pictures stored in the tag
            NB1 : PictureInfo.PictureData (raw binary picture data) is valued
            NB2 : Also allows to value embedded pictures inside chapters
            </summary>
        </member>
        <member name="F:ATL.Track.stream">
            <summary>
            Stream used to access in-memory Track contents (alternative to path, which is used to access on-disk Track contents)
            </summary>
        </member>
        <member name="F:ATL.Track.mimeType">
            <summary>
            MIME-type that describes in-memory Track contents (used in conjunction with stream)
            </summary>
        </member>
        <member name="T:ATL.Factory">
            <summary>
            Abstract factory for data readers, containing shared methods and members
            </summary>
        </member>
        <member name="M:ATL.Factory.addFormat(ATL.Format)">
            <summary>
            Adds a format to the supported formats
            </summary>
            <param name="f">Format to be added</param>
        </member>
        <member name="M:ATL.Factory.getFormatsFromPath(System.String)">
            <summary>
            Gets the valid formats from the given file path, using the file extension as key
            </summary>
            <param name="path">Path of the file which format to recognize</param>
            <returns>List of the valid formats matching the extension of the given file, 
            or null if none recognized or the file does not exist</returns>
        </member>
        <member name="M:ATL.Factory.getFormatsFromMimeType(System.String)">
            <summary>
            Gets the valid formats from the given MIME-type
            </summary>
            <param name="mimeType">MIME-type to recognize</param>
            <returns>List of the valid formats matching the MIME-type of the given file, 
            or null if none recognized</returns>
        </member>
        <member name="M:ATL.Factory.getFormats">
            <summary>
            Gets a list of all supported formats
            </summary>
            <returns>List of all supported formats</returns>
        </member>
        <member name="T:ATL.Logging.ILogDevice">
            <summary>
            This interface describes a logical device able to log messages
            </summary>
        </member>
        <member name="M:ATL.Logging.ILogDevice.DoLog(ATL.Logging.Log.LogItem)">
            <summary>
            Logs the message described by the provided LogItem object
            </summary>
            <param name="anItem">Data concerning the message to be logged</param>
        </member>
        <member name="T:ATL.Logging.Log">
            <summary>
            This class handles the logging of the application's messages
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.Debug(System.String)">
            <summary>
            Logs the provided message with the LV_DEBUG logging level
            </summary>
            <param name="msg">Contents of the message</param>
        </member>
        <member name="M:ATL.Logging.Log.Info(System.String)">
            <summary>
            Logs the provided message with the LV_INFO logging level
            </summary>
            <param name="msg">Contents of the message</param>
        </member>
        <member name="M:ATL.Logging.Log.Warning(System.String)">
            <summary>
            Logs the provided message with the LV_WARNING logging level
            </summary>
            <param name="msg">Contents of the message</param>
        </member>
        <member name="M:ATL.Logging.Log.Error(System.String)">
            <summary>
            Logs the provided message with the LV_ERROR logging level
            </summary>
            <param name="msg">Contents of the message</param>
        </member>
        <member name="M:ATL.Logging.Log.SetLocation(System.String)">
            <summary>
            Set current location
            
            NB : Implementation is based on current thread ID, 
            so that Log object can be accessed by multiple threads,
            each setting its own location
            </summary>
            <param name="location">Location value</param>
        </member>
        <member name="M:ATL.Logging.Log.Write(System.Int32,System.String)">
            <summary>
            Logs the provided message with the provided logging level
            </summary>
            <param name="level">Logging level of the new message</param>
            <param name="msg">Contents of the new message</param>
            <param name="forceDisplay">If true, forces all registered ILogDevices to immediately log the message, even if asynchoronous logging is enabled</param>
        </member>
        <member name="M:ATL.Logging.Log.doWrite(ATL.Logging.Log.LogItem,System.Boolean)">
            <summary>
            Logs the provided message with the provided logging level
            </summary>
            <param name="theItem">Message to log</param>
            <param name="forceDisplay">If true, forces all registered ILogDevices to immediately log the message, even if asynchoronous logging is enabled</param>
        </member>
        <member name="M:ATL.Logging.Log.ClearAll">
            <summary>
            Clears the whole list of logged items
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.GetAllItems">
            <summary>
            Gets all the logged items 
            </summary>
            <returns>List of all the logged items</returns>
        </member>
        <member name="M:ATL.Logging.Log.GetAllItems(System.Int32)">
            <summary>
            Gets the logged items whose logging level matches the provided mask 
            </summary>
            <param name="levelMask">Logging level mask</param>
            <returns>List of the matching logged items</returns>
        </member>
        <member name="M:ATL.Logging.Log.Register(ATL.Logging.ILogDevice)">
            <summary>
            Registers a LogDevice
            A registered LogDevice will be called each time a new LogItem is received
            (see Write method) 
            </summary>
            <param name="aLogger">Device to register</param>
        </member>
        <member name="M:ATL.Logging.Log.SwitchAsync">
            <summary>
            Marks logging as asynchronous : no call will be made
            to LogDevice.DoLog until FlushQueue or Release are called
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.FlushQueue">
            <summary>
            Flushes all queued LogItems through call to LogDevice.DoLog
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.SwitchSync">
            <summary>
            Makes logging synchronous again and flushes remaining LogItems in queue
            </summary>
        </member>
        <member name="T:ATL.Logging.LogDelegator">
            <summary>
            This class is the static entry point for all logging operations
            </summary>
        </member>
        <member name="M:ATL.Logging.LogDelegator.SetLog(ATL.Logging.Log@)">
            <summary>
            Sets the delegate to the Write method of the Log object 
            used for logging messages
            </summary>
            <param name="theLog">Log to be used</param> 
        </member>
        <member name="M:ATL.Logging.LogDelegator.GetLogDelegate">
            <summary>
            Gets the delegate routine to use for logging messages
            </summary>
            <returns>Delegate routine object to be used</returns>
        </member>
        <member name="M:ATL.Logging.LogDelegator.GetLocateDelegate">
            <summary>
            Gets the delegate routine to use for setting location
            </summary>
            <returns>Delegate routine object to be used</returns>
        </member>
        <member name="T:ATL.Playlist.IO.ASXIO">
            <summary>
            ASX playlist manager
            
            Implementation notes : Playlist items other than local files (e.g. file accessible via HTTP) are not supported
            </summary>
        </member>
        <member name="T:ATL.Playlist.IO.B4SIO">
            <summary>
            B4S playlist manager
            </summary>
        </member>
        <member name="T:ATL.Playlist.IO.FPLIO">
            <summary>
            Foobar2000 EXPERIMENTAL playlist reader
            Since the format is not open and can be subject to change by
            fb2k developers at any time, this reader is experimental : it is not guaranteed 
            to work with all versions of FPL files
            </summary>
        </member>
        <member name="T:ATL.Playlist.IO.M3UIO">
            <summary>
            M3U/M3U8 playlist manager
            </summary>
        </member>
        <member name="T:ATL.Playlist.IO.PLSIO">
            <summary>
            PLS playlist manager
            </summary>
        </member>
        <member name="T:ATL.Playlist.IO.SMILIO">
            <summary>
            SMIL playlist manager
            
            This is a very basic implementation that lists every single audio file in the playlist
            
            Implementation notes : Playlist items other than local files (e.g. file accessible via HTTP) are not supported
            </summary>
        </member>
        <member name="T:ATL.Playlist.IO.XSPFIO">
            <summary>
            XSPF (spiff) playlist manager
            
            Implementation notes : Playlist items other than local files (e.g. file accessible via HTTP) are not supported
            </summary>
        </member>
        <member name="T:ATL.Playlist.IPlaylistIO">
            <summary>
            Interface for standard playlist I/O classes
            </summary>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.Path">
            <summary>
            Absolute path of the playlist file
            </summary>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.LocationFormatting">
            <summary>
            Location formatting to use when writing the file
            </summary>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.Encoding">
            <summary>
            Encoding convention to use when writing the file
            </summary>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.FilePaths">
            <summary>
            Gets the absolute paths of all files registered in the playlist
            NB : The existence of the files is not checked when getting them
            </summary>
            <returns>Array containing all paths</returns>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.Tracks">
            <summary>
            Gest all the tracks registered in the playlist
            </summary>
            <returns>Array containing all tracks</returns>
        </member>
        <member name="T:ATL.Playlist.PlaylistIO">
            <summary>
            Asbtract parent for all playlist manipulation (I/O) classes
            Contrains all common methods and attributes
            </summary>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.encodeLocation(System.String)">
            <summary>
            Encodes the given location usingcurrent LocationFormatting
            </summary>
            <param name="location">File path to encode</param>
            <returns></returns>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.decodeLocation(System.Xml.XmlReader,System.String,System.Collections.Generic.IList{System.String})">
            <summary>
            Decodes the given location to an absolute filepath and adds it to the given list
            </summary>
            <param name="source">Xml source to get the location from</param>
            <param name="attributeName">Attribute name in current Xml source to get the location from</param>
            <param name="result">List of locations to add the found location to</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.decodeLocation(System.String)">
            <summary>
            Decodes the given location to an absolute filepath
            </summary>
            <param name="href">Location to decode (can be an URI of any form or a relative filepath)</param>
            <returns>Absolute filepath corresponding to the given location</returns>
        </member>
        <member name="T:ATL.Playlist.PlaylistIOFactory">
            <summary>
            Factory for playlist I/O classes
            </summary>
        </member>
        <member name="T:ATL.BufferedBinaryReader">
            <summary>
            Reads data from the given Stream using a forward buffer in order to reduce disk stress and have better control of when data is actually read from the disk.
            
            NB1 : Using BufferedBinaryReader instead of the classic BinaryReader create a 10% speed gain on the dev environment (MS .NET under Windows)
            
            NB2 : The interface of this class is designed to be called exactly like a BinaryReader in order to facilitate swapping in classes that use BinaryReader
            However, is does _not_ give access to BaseStream, in order to keep control on buffer and cursor positions.
            
            NB3 : This class implements Stream in order to be reusable in methods that take Stream as an input
            </summary>
        </member>
        <member name="T:ATL.StreamUtils">
            <summary>
            Misc. utilities used by binary readers
            </summary>
        </member>
        <member name="T:ATL.StreamUtils.StreamHandlerDelegate">
            <summary>
            Handler signature to be used when needing to process a MemoryStream
            </summary>
        </member>
        <member name="M:ATL.StreamUtils.StringEqualsArr(System.String,System.Char[])">
            <summary>
            Determines if the contents of a string (character by character) is the same
            as the contents of a char array
            </summary>
            <param name="a">String to be tested</param>
            <param name="b">Char array to be tested</param>
            <returns>True if both contain the same character sequence; false if not</returns>
        </member>
        <member name="M:ATL.StreamUtils.ArrEqualsArr(System.Char[],System.Char[])">
            <summary>
            Determines if two char arrays have the same contents
            </summary>
            <param name="a">First array to be tested</param>
            <param name="b">Second array to be tested</param>
            <returns>True if both arrays have the same contents; false if not</returns>
        </member>
        <member name="M:ATL.StreamUtils.ArrEqualsArr(System.Byte[],System.Byte[])">
            <summary>
            Determines if two byte arrays have the same contents
            </summary>
            <param name="a">First array to be tested</param>
            <param name="b">Second array to be tested</param>
            <returns>True if both arrays have the same contents; false if not</returns>
        </member>
        <member name="M:ATL.StreamUtils.CopyStream(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Copies a given number of bytes from a given stream to another, starting at current stream positions
            i.e. first byte will be read at from.Position and written at to.Position
            NB : This method cannot be used to move data within one single stream; use CopySameStream instead
            </summary>
            <param name="from">Stream to start copy from</param>
            <param name="to">Stream to copy to</param>
            <param name="length">Number of bytes to copy (optional; default = 0 = all bytes until the end of the 'from' stream)</param>
        </member>
        <member name="M:ATL.StreamUtils.ShortenStream(System.IO.Stream,System.Int64,System.UInt32)">
            <summary>
            Remove a portion of bytes within the given stream
            </summary>
            <param name="s">Stream to process; must be accessible for reading and writing</param>
            <param name="endOffset">End offset of the portion of bytes to remove</param>
            <param name="delta">Number of bytes to remove</param>
        </member>
        <member name="M:ATL.StreamUtils.LengthenStream(System.IO.Stream,System.Int64,System.UInt32,System.Boolean)">
            <summary>
            Add bytes within the given stream
            </summary>
            <param name="s">Stream to process; must be accessible for reading and writing</param>
            <param name="oldIndex">Offset where to add new bytes</param>
            <param name="delta">Number of bytes to add</param>
            <param name="fillZeroes">If true, new bytes will all be zeroes (optional; default = false)</param>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEUInt16(System.Byte[])">
            <summary>
            Decodes an unsigned Big-Endian 16-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEUInt16(System.UInt16)">
            <summary>
            Encodes the given value into an array of bytes as a Big-Endian 16-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeUInt16(System.Byte[])">
            <summary>
            Decodes an unsigned Little-Endian 16-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeInt16(System.Byte[])">
            <summary>
            Decodes an signed Little-Endian 16-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEInt16(System.Int16)">
            <summary>
            Encodes the given value into an array of bytes as a Big-Endian 16-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEInt16(System.Byte[])">
            <summary>
            Decodes a signed Big-Endian 16-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEInt24(System.Byte[])">
            <summary>
            Decodes a signed Big-Endian 24-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEUInt24(System.Byte[],System.Int32)">
            <summary>
            Decodes an unsigned Big-Endian 24-bit integer from the given array of bytes, starting from the given offset
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <param name="offset">Offset to read value from (default : 0)</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEUInt24(System.UInt32)">
            <summary>
            Encodes the given value into an array of bytes as a Big-Endian 24-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEUInt32(System.Byte[])">
            <summary>
            Decodes an unsigned Big-Endian 32-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeUInt32(System.Byte[])">
            <summary>
            Decodes an unsigned Little-Endian 32-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEUInt32(System.UInt32)">
            <summary>
            Encodes the given value into an array of bytes as a Big-Endian unsigned 32-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEInt32(System.Byte[])">
            <summary>
            Decodes a signed Big-Endian 32-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEInt32(System.Int32)">
            <summary>
            Encodes the given value into an array of bytes as a Big-Endian 32-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeInt32(System.Byte[])">
            <summary>
            Decodes a signed Little-Endian 32-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeUInt64(System.Byte[])">
            <summary>
            Decodes an unsigned Little-Endian 64-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEInt64(System.Byte[])">
            <summary>
            Decodes a signed Big-Endian 64-bit integer from the given array of bytes
            </summary>
            <param name="value">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEUInt64(System.UInt64)">
            <summary>
            Encodes the given value into an array of bytes as a Big-Endian unsigned 64-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.ReverseInt32(System.Int32)">
            <summary>
            Switches the format of a signed Int32 between big endian and little endian
            </summary>
            <param name="n">value to convert</param>
            <returns>converted value</returns>
        </member>
        <member name="M:ATL.StreamUtils.GetEncodingFromFileBOM(System.IO.FileStream)">
            <summary>
            Guesses the encoding from the file Byte Order Mark (BOM)
            http://en.wikipedia.org/wiki/Byte_order_mark 
            NB : This obviously only works for files that actually start with a BOM
            </summary>
            <param name="file">FileStream to read from</param>
            <returns>Detected encoding; system Default if detection failed</returns>
        </member>
        <member name="M:ATL.StreamUtils.ReadNullTerminatedString(System.IO.BinaryReader,System.Text.Encoding)">
            <summary>
            Reads a null-terminated String from the given BinaryReader, according to the given Encoding
            Returns with the BinaryReader positioned after the last null-character(s)
            </summary>
            <param name="r">BinaryReader positioned at the beginning of the String to be read</param>
            <param name="encoding">Encoding to use for reading the stream</param>
            <returns>Read value</returns>
        </member>
        <member name="M:ATL.StreamUtils.ReadNullTerminatedStringFixed(System.IO.BinaryReader,System.Text.Encoding,System.Int32)">
            <summary>
            Reads a null-terminated String from the given BinaryReader, according to the given Encoding, within a given limit of bytes
            Returns with the BinaryReader positioned at (start+limit)
            </summary>
            <param name="r">BinaryReader positioned at the beginning of the String to be read</param>
            <param name="encoding">Encoding to use for reading the stream</param>
            <param name="limit">Maximum number of bytes to read</param>
            <returns>Read value</returns>
        </member>
        <member name="M:ATL.StreamUtils.readNullTerminatedString(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Reads a null-terminated string using the giver BinaryReader
            </summary>
            <param name="r">Stream reader to read the string from</param>
            <param name="encoding">Encoding to use to parse the read bytes into the resulting String</param>
            <param name="limit">Limit (in bytes) of read data (0=unlimited)</param>
            <param name="moveStreamToLimit">Indicates if the stream has to advance to the limit before returning</param>
            <returns>The string read, without the zeroes at its end</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeSynchSafeInt(System.Byte[])">
            <summary>
            Extracts a signed 32-bit integer from a byte array using the "synch-safe" convention
            as to ID3v2 definition (6.2)
            </summary>
            <param name="bytes">Byte array containing data
            NB : Array size can vary from 1 to 5 bytes, as only 7 bits of each is actually used
            </param>
            <returns>Decoded Int32</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeSynchSafeInt32(System.Byte[])">
            <summary>
            Decodes a signed 32-bit integer from a 4-byte array using the "synch-safe" convention
            as to ID3v2 definition (6.2)
            NB : The actual capacity of the integer thus reaches 28 bits
            </summary>
            <param name="bytes">4-byte array containing to convert</param>
            <returns>Decoded Int32</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeSynchSafeInt(System.Int32,System.Int32)">
            <summary>
            Encodes the given values as a (nbBytes*8)-bit integer to a (nbBytes)-byte array using the "synch-safe" convention
            as to ID3v2 definition (6.2)
            </summary>
            <param name="value">Value to encode</param>
            <param name="nbBytes">Number of bytes to encode to (can be 1 to 5)</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeSynchSafeInt32(System.Int32)">
            <summary>
            Encodes the given value as a 32-bit integer to a 4-byte array using the "synch-safe" convention
            as to ID3v2 definition (6.2)
            </summary>
            <param name="value">Integer to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.FindSequence(System.IO.Stream,System.Byte[],System.Int64)">
            <summary>
            Finds a byte sequence within a stream
            </summary>
            <param name="stream">Stream to search into</param>
            <param name="sequence">Sequence to find</param>
            <param name="limit">Maximum distance (in bytes) of the sequence to find.
            Put 0 for an infinite distance</param>
            <returns>
                true if the sequence has been found; the stream will be positioned on the 1st byte following the sequence
                false if the sequence has not been found; the stream will keep its initial position
            </returns>
        </member>
        <member name="M:ATL.StreamUtils.ReadBits(System.IO.BinaryReader,System.Int32,System.Int32)">
            <summary>
            Reads the given number of bits from the given position and converts it to an unsigned int32
            according to big-endian convention
            
            NB : reader position _always_ progresses by 4, no matter how many bits are needed
            </summary>
            <param name="source">BinaryReader to read the data from</param>
            <param name="bitPosition">Position of the first _bit_ to read (scale is x8 compared to classic byte positioning) </param>
            <param name="bitCount">Number of bits to read</param>
            <returns>Unsigned int32 formed from read bits, according to big-endian convention</returns>
        </member>
        <member name="M:ATL.StreamUtils.ExtendedToDouble(System.Byte[])">
            <summary>Converts the given extended-format byte array (which
            is assumed to be in little-endian form) to a .NET Double,
            as closely as possible. Values which are too small to be 
            represented are returned as an appropriately signed 0. Values 
            which are too large
            to be represented (but not infinite) are returned as   
            Double.NaN,
            as are unsupported values and actual NaN values.</summary>
            
            Credits : Jon Skeet (http://groups.google.com/groups?selm=MPG.19a6985d4683f5d398a313%40news.microsoft.com)
        </member>
        <member name="M:ATL.StreamUtils.FromComponents(System.Int32,System.Int32,System.Int64)">
            <summary>Returns a double from the IEEE sign/exponent/fraction
            components.</summary>
            
            Credits : Jon Skeet (http://groups.google.com/groups?selm=MPG.19a6985d4683f5d398a313%40news.microsoft.com)
        </member>
        <member name="T:HashDepot.Fnv1a">
            <summary>
            FNV-1a Hash functions
            </summary>
        </member>
        <member name="M:HashDepot.Fnv1a.Hash32(System.Byte[])">
            <summary>
            Calculate 32-bit FNV-1a hash value
            </summary>
        </member>
        <member name="M:Commons.ImageUtils.GetMimeTypeFromImageFormat(Commons.ImageFormat)">
            <summary>
            Returns the mime-type of the given .NET image format
            NB : This function is restricted to most common embedded picture formats : JPEG, GIF, PNG, BMP
            </summary>
            <param name="imageFormat">Image format whose mime-type to obtain</param>
            <returns>mime-type of the given image format</returns>
        </member>
        <member name="M:Commons.ImageUtils.GetImageFormatFromMimeType(System.String)">
            <summary>
            Returns the .NET image format of the given mime-type
            NB1 : This function is restricted to most common embedded picture formats : JPEG, GIF, PNG, BMP
            NB2 : This function does not verify the syntax of the mime-type (e.g. "image/XXX"), and only focuses on the presence of specific substrings (e.g. "gif")
            </summary>
            <param name="mimeType">Mime-type whose ImageFormat to obtain</param>
            <returns>ImageFormat of the given mime-type (default : JPEG)</returns>
        </member>
        <member name="M:Commons.ImageUtils.GetImageFormatFromPictureHeader(System.Byte[])">
            <summary>
            Detects image format from the given signature
            </summary>
            <param name="header">Binary signature; must be at least 3-bytes long</param>
            <returns>Detected image format corresponding to the given signature; null if no match is found</returns>
        </member>
        <member name="T:Commons.Utils">
            <summary>
            General utility class
            </summary>
        </member>
        <member name="T:Commons.Utils.voidDelegate">
            <summary>
            Defines a delegate that does not carry any argument (useful for "pinging")
            </summary>
        </member>
        <member name="P:Commons.Utils.Latin1Encoding">
            <summary>
            ISO-8859-1 encoding
            </summary>
        </member>
        <member name="M:Commons.Utils.ProtectValue(System.String)">
            <summary>
            Transforms the given string so that is becomes non-null
            </summary>
            <param name="value">String to protect</param>
            <returns>Given string if non-null; else empty string</returns>
        </member>
        <member name="M:Commons.Utils.EncodeTimecode_ms(System.Int64)">
            <summary>
            Format the given duration using the following format
                DDdHH:MM:SS.UUUU
                
             Where
                DD is the number of days, if applicable (i.e. durations of less than 1 day won't display the "DDd" part)
                HH is the number of hours, if applicable (i.e. durations of less than 1 hour won't display the "HH:" part)
                MM is the number of minutes
                SS is the number of seconds
                UUUU is the number of milliseconds
            </summary>
            <param name="milliseconds">Duration to format (in milliseconds)</param>
            <returns>Formatted duration according to the abovementioned convention</returns>
        </member>
        <member name="M:Commons.Utils.EncodeTimecode_s(System.Int64)">
            <summary>
            Format the given duration using the following format
                DDdHH:MM:SS
                
             Where
                DD is the number of days, if applicable (i.e. durations of less than 1 day won't display the "DDd" part)
                HH is the number of hours, if applicable (i.e. durations of less than 1 hour won't display the "HH:" part)
                MM is the number of minutes
                SS is the number of seconds
            </summary>
            <param name="seconds">Duration to format (in seconds)</param>
            <returns>Formatted duration according to the abovementioned convention</returns>
        </member>
        <member name="M:Commons.Utils.DecodeTimecodeToMs(System.String)">
            <summary>
            Converts the duration of the given timecode to milliseconds
            Supported formats : hh:mm, hh:mm:ss.ddd, mm:ss, hh:mm:ss and mm:ss.ddd
            </summary>
            <param name="timeCode">Timecode to convert</param>
            <returns>Duration of the given timecode expressed in milliseconds if succeeded; -1 if failed</returns>
        </member>
        <member name="M:Commons.Utils.StripEndingZeroChars(System.String)">
            <summary>
            Strips the given string from all ending null '\0' characters
            </summary>
            <param name="iStr">String to process</param>
            <returns>Given string, without any ending null character</returns>
        </member>
        <member name="M:Commons.Utils.BuildStrictLengthString(System.Int32,System.Int32,System.Char,System.Boolean)">
            <summary>
            Transforms the given string to format with the given length, expressed in number of characters
             - If the given length is shorter than the actual length of the string, it will be truncated
             - If the given length is longer than the actual length of the string, it will be right/left-padded with a given character
            </summary>
            <param name="value">String to transform</param>
            <param name="length">Target length of the final string</param>
            <param name="paddingChar">Character to use if padding is needed</param>
            <param name="padRight">True if the padding has to be done on the right-side of the target string; 
            false if the padding has to be done on the left-side (optional; default value = true)</param>
            <returns>Reprocessed string of given length, according to rules documented in the method description</returns>
        </member>
        <member name="M:Commons.Utils.BuildStrictLengthStringBytes(System.String,System.Int32,System.Byte,System.Text.Encoding,System.Boolean)">
            <summary>
            Transforms the given string to format with the given length, expressed in number of bytes
             - If the given length is shorter than the actual length of the string, it will be truncated
             - If the given length is longer than the actual length of the string, it will be right/left-padded with a given byte
            </summary>
            <param name="value">String to transform</param>
            <param name="targetLength">Target length of the final string</param>
            <param name="paddingByte">Byte to use if padding is needed</param>
            <param name="encoding">Encoding to use to represent the given string in binary format</param>
            <param name="padRight">True if the padding has to be done on the right-side of the target string; 
            false if the padding has to be done on the left-side (optional; default value = true)</param>
            <returns>Reprocessed string of given length, in binary format, according to rules documented in the method description</returns>
        </member>
        <member name="M:Commons.Utils.ToBoolean(System.String)">
            <summary>
            Coverts given string value to boolean.
              - Returns true if string represents a non-null numeric value or the word "true"
              - Returns false if not
              
            NB : This implementation exists because default .NET implementation has a different convention as for parsing numbers
            </summary>
            <param name="value">Value to be converted</param>
            <returns>Resulting boolean value</returns>
        </member>
        <member name="M:Commons.Utils.DecodeFrom64(System.Byte[])">
            <summary>
            The method to Decode your Base64 strings.
            </summary>
            <param name="encodedData">The String containing the characters to decode.</param>
            <param name="s">The Stream where the resulting decoded data will be written.</param>
            Source : http://blogs.microsoft.co.il/blogs/mneiter/archive/2009/03/22/how-to-encoding-and-decoding-base64-strings-in-c.aspx
        </member>
        <member name="M:Commons.Utils.EncodeTo64(System.Byte[])">
            <summary>
            Convert the given input to a Base64 UUencoded output
            </summary>
            <param name="data">Data to be encoded</param>
            <returns>Encoded data</returns>
        </member>
        <member name="M:Commons.Utils.IsNumeric(System.String,System.Boolean)">
            <summary>
            Indicates if the given string is exclusively composed of digital charachers
            
            NB1 : decimal separators '.' and ',' are tolerated except if allowsOnlyIntegers argument is set to True
            NB2 : whitespaces ' ' are not tolerated
            NB3 : any alternate notation (e.g. exponent, hex) is not tolerated
            </summary>
            <param name="s">String to analyze</param>
            <param name="allowsOnlyIntegers">Set to True if IsNumeric should reject decimal values; default = false</param>
            <returns>True if the string is a digital value; false if not</returns>
        </member>
        <member name="M:Commons.Utils.IsHex(System.String)">
            <summary>
            Indicates if the given string is hexadecimal notation
            </summary>
            <param name="s">String to analyze</param>
            <returns>True if the string is a hexadecimal notation; false if not</returns>
        </member>
        <member name="M:Commons.Utils.ParseDouble(System.String)">
            <summary>
            Parses the given string into a Double value; returns 0 if parsing fails
            </summary>
            <param name="s">String to be parsed</param>
            <returns>Parsed value; 0 if a parsing issue has been encountered</returns>
        </member>
    </members>
</doc>
